#!/usr/bin/env python

import datetime
import os
import glob
import time
import re
import gzip
import socket
import sys

concurrent = True
try:
	from multiprocessing import Process, Lock
except:
	print("Multiprocessing not available: Python version:\n" + sys.version)
	concurrent = False


DEBUG = "No"

class TimberAlGrep:
	# Compute files to check
	@staticmethod
	def fileLogic(start, end):
		ts = None
		te = None
		try:
			ts = datetime.datetime.fromtimestamp(time.mktime(time.strptime(start, "%Y-%m-%d-%H-%M")))
			te = datetime.datetime.fromtimestamp(time.mktime(time.strptime(end, "%Y-%m-%d-%H-%M")))
		except:
			print("Could not convert date: " + start + "  " + end + ". Needs to be %Y-%m-%d-%H-%M")
			sys.exit(1)
		# Expand date to folder paths
		ti = ts
		filelist = []
		while ti <= te:
			prodpath = "/onlinelogs/SERVICE_P/REGION_P/Prod/" + str(ti.year) + "/" + str(ti.month).zfill(2) + "/" + str(ti.day).zfill(2) + "/" + str(ti.hour).zfill(2) + "/"
			onebpath = "/onlinelogs/SERVICE_P/REGION_P/OneBox/Prod/" + str(ti.year) + "/" + str(ti.month).zfill(2) + "/" + str(ti.day).zfill(2) + "/" + str(ti.hour).zfill(2) + "/"
			if DEBUG == "Yes":
				print(prodpath + "appli*.*")
				print(onebpath + "appli*.*")
			filelist.extend(glob.glob(prodpath + "appli*.*"))
			filelist.extend(glob.glob(onebpath + "appli*.*"))
			ti = ti + datetime.timedelta(hours = 1)
		if DEBUG == "Yes":
			print(filelist)
		return filelist

	@staticmethod
	def grep(filename):
		fp = gzip.open(filename, "r")
		buff = fp.readlines()
		fp.close()
		retStr = "FILESTART: " + filename.split("/")[-1] + "\n"
		for i in range(0, len(buff), 1):
			sObj = re.search("(\d\d .* \d\d\d\d \d\d:\d\d:\d\d).*\[QUERY_P\] (.*)", buff[i])
			if sObj:
				timeStr = sObj.group(1)
				message = sObj.group(2)
				#print("[QUERY_P]\n[Time: " + timeStr + "]\n[Message: " + message + "]")
				retStr = retStr + ("[QUERY_P]\n[Time: " + timeStr + "]\n[Message: " + message + "]") + "\n"
				i = i + 1
				while i < len(buff) and not re.search("\d\d .* \d\d\d\d \d\d:\d\d:\d\d.*", buff[i]):
					#print(buff[i].rstrip())
					retStr = retStr + (buff[i].rstrip()) + "\n"
					i = i + 1
				i = i - 1
				#print("------------------------------------------------\n\n")
				retStr = retStr + "------------------------------------------------\n\n"
		retStr = retStr + "FILEEND " + filename.split("/")[-1] + "\n\n"
		return retStr
	
	@staticmethod
	def worker(fileList, lock):
		print("Worker started ...")
		print("# files to process: " + str(len(fileList)))
		for f in fileList:
			retStr = TimberAlGrep.grep(f)
			lock.acquire()
			print(retStr)
			lock.release()
		
	@staticmethod
	def execute(fileList):
		dataSize = len(fileList)
		fileList1 = fileList[0:dataSize / 4]
		fileList2 = fileList[dataSize // 4 + 1 : dataSize // 2]
		fileList3 = fileList[dataSize // 2 + 1 : 3 * dataSize // 4]
		fileList4 = fileList[3 * dataSize // 4 + 1 : dataSize -1]
		lock = Lock()
		p1 = Process(target = TimberAlGrep.worker, args = (fileList1, lock))
		p2 = Process(target = TimberAlGrep.worker, args = (fileList2, lock))
		p3 = Process(target = TimberAlGrep.worker, args = (fileList3, lock))
		p4 = Process(target = TimberAlGrep.worker, args = (fileList4, lock))
		p1.start()
		p2.start()
		p3.start()
		p4.start()
		p1.join()
		p2.join()
		p3.join()
		p4.join()
	
def main():
	filelist = TimberAlGrep.fileLogic("START_P", "END_P")
	if DEBUG == "Yes":
		print("Start: START_P End: END_P")
	
	if len(filelist) > 4 and concurrent == True:
		print("Executing concurrently ...")
		TimberAlGrep.execute(filelist)
	else:
		for f in filelist:
			print(TimberAlGrep.grep(f))

if __name__ == "__main__":
	main()

